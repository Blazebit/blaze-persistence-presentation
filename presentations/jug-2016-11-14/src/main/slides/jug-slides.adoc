= Blaze-Persistence, Tomorrow's JPA, today
Christian Beikov, Moritz Becker
:icons: font
:split:
:navigation:
:blank: pass:[ +]
:markstart: pass:[<span class="mark">]
:markend: pass:[</span>]

== About us

image::vendor.png[float="right"]

icon:twitter[] https://twitter.com/Blazebit[@Blazebit] +
icon:github[] https://github.com/Blazebit

Blazebit Gesbr. is a working group doing commercial software and OSS under APL 2.0

[%step]
--
image::christian_head.png[float="right"]

{blank}

* Christian Beikov, Blaze-Persistence lead

--

[%step]
--
image::moritz_head.png[float="right"]

{blank}

* Moritz Becker, Blaze-Persistence comitter

--

[%step]
--
image::bernd_head.png[float="right"]

{blank}

* Bernd Artm+++&uuml;+++ller, Designer

--

== What is Blaze-Persistence

// TODO: Need a new logo
//image::logo.png[role="logo"]

* Library that builds on top of JPA with deep integration
* Fluent builder API that is easy to use
* Rich pagination support integrated
* Entity-Views as painless DTOs
* Advanced SQL support on top of JPA model

== Problems with ORM/JPA

// List the problems that people have with ORMs and show the bad decisions that have to be made because of that.

Think JPA 2.1 Entity-Graphs are too verbose?

[source,java]
----
@Entity
@NamedEntityGraph(
    name = "Cat.catWithKittensParents",
    attributeNodes = @NamedAttributeNode(value = "kittens", subgraph = "kittens"),
    subgraphs = @NamedSubgraph(name = "kittens", attributeNodes = {
        @NamedAttributeNode("father"), @NamedAttributeNode("mother")
    })
)
public class Cat {
    @Id @GeneratedValue
    private Integer id;
    private String name;
    @OneToMany
    private Set<Cat> kittens;
    @ManyToOne(fetch = Fetch.LAZY)
    private Cat mother;
    @ManyToOne(fetch = Fetch.LAZY)
    private Cat father;
}
----

<<<

Fetch-problems with loading the _"whole"_ database or `LazyInitializationExceptions`?

[source,java,subs="verbatim,attributes"]
----
public class Cat {
    @Id @GeneratedValue
    private Integer id;
    private String name;
    @OneToMany(fetch = Fetch.EAGER)
    private Set<Cat> kittens;
    @ManyToOne(fetch = Fetch.EAGER)
    private Cat mother;
    @ManyToOne(fetch = Fetch.EAGER)
    private Cat father;
}
----

[source,java]
----
entityManager.find(Cat.class, catId);
----

Leading to loading all relations...

<<<

Fetch-problems with loading the _"whole"_ database or `LazyInitializationExceptions`?

[source,java,subs="verbatim,attributes"]
----
public class Cat {
    @Id @GeneratedValue
    private Integer id;
    private String name;
    @OneToMany(fetch = Fetch.{markstart}LAZY{markend})
    private Set<Cat> kittens;
    @ManyToOne(fetch = Fetch.{markstart}LAZY{markend})
    private Cat mother;
    @ManyToOne(fetch = Fetch.{markstart}LAZY{markend})
    private Cat father;
}
----

[source,java]
----
Cat c = entityManager.find(Cat.class, catId);
entityManager.close();
// ...
c.getFather().getName();
----

Leading to a `LazyInitializationExceptions` on invocation of `getName()`

<<<

JPA constructor expressions for DTOs too inflexible?

[source,sql]
----
SELECT new com.company.somepackage.dto.MyCatDTO(
    c.name, kitten.name, father.name, mother.name
) FROM Cat c
LEFT JOIN FETCH c.kittens kitten
LEFT JOIN FETCH kitten.father father
LEFT JOIN FETCH kitten.mother mother
----

Results in flat objects, no hierarchies possible except you do something like that...

[source,java]
----
entityManager.createQuery(query, MyCatDTO.class)
    .getResultList()
    .stream()
    .collect(Collectors.groupingBy(MyCatDTO::getName, dto -> new MySubCatDTO(dto))
    .entrySet()
    .stream()
    .map(entry -> new MyMainCatDTO(entry.getKey(), entry.getValue()))
    .collect(Collectors.toList());
----

<<<

Missing support for that one little SQL feature that you really need?

[%step]
--
Set operations
--

[%step]
--
[source,sql]
----
SELECT c.name FROM Cat c
UNION ALL
SELECT p.name FROM Person p
----
--

[%step]
--
Modification CTEs
--

[%step]
--
[source,sql]
----
WITH MyCte(id) AS(
    UPDATE Cat c SET age = age + 1 RETURNING id
)
SELECT c.id FROM MyCte c
----
--

<<<

Having some longstanding problems with the JPA provider that don't seem to get fixed?

[%step]
--
`HHH-9329`:: Left join semantics broken when using `ON` clause on collection table attribute
--

[%step]
--
`HHH-11042`:: Count distinct support for DBMS that don't natively support it
--

[%step]
--
`HHH-1615`:: Group by entity
--

[%step]
--
`HHH-10241`:: Buggy MySQL code generation for null precedence
--

[%step]
--
{blank}
{blank}
+++<p style="text-align: center; font-style: italic;">many more issues that are worked around automatically in Blaze-Persistence...</p>+++
--

<<<

Feel like you can't reuse parts of queries and have to duplicate code?

[%step]
--
[source,sql]
----
SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.kittens kitten
WHERE cat.name LIKE :catName
  AND cat.age > :catAge
----
--

[%step]
--
which is very similar to...
--

[%step]
--
[source,sql]
----
SELECT cat
FROM Cat cat
LEFT JOIN FETCH cat.father
LEFT JOIN FETCH cat.mother
WHERE cat.name LIKE :catName
  AND cat.age > :catAge
----
--

<<<

* Think JPA 2.1 Entity-Graphs are too verbose?
* Fetch-problems with loading the _"whole"_ database or `LazyInitializationExceptions`?
* JPA constructor expressions for DTOs too inflexible?
* Missing support for that one little SQL feature that you really need?
* Having some longstanding problems with the JPA provider that don't seem to get fixed?
* Feel like you can't reuse parts of queries and have to duplicate code?

[%step]
--
{blank}
+++<h3 style="text-align: center; font-size: 2em;">Blaze-Persistence got you covered!</h3>+++
--

[%step]
--
{blank}
{blank}
+++<p style="text-align: center; font-style: italic;">Let's see how Blaze-Persistence helps you out with these problems!</p>+++
--

[canvas-image="images/features_are_coming.jpg"]
== Blaze-Persistence features

// List the features/use cases for which Blaze-Persistence can be used. For every feature, give live examples + comparison

== Entity-views

Entity-views are the ORM equivalent of database views.

* You can use them to optimize entity fetching
* Most of the time you do not need full entities
* Querying only the parts you need reduces data transfer

Some example use cases:

* Display data in UI
* Fetch data to be returned in REST resources
* Partial updates in the works

== Example View - Basic

[source,java]
----
@EntityView(Cat.class)
public interface CatView {

    @IdMapping("id")
    Integer getId();

    String getName();

    @Mapping("LOWER(name)")
    String getLowerCaseName();

    @Mapping("SIZE(kittens)")
    Integer getNumKittens();
}
----

== Example View - Subquery support

[source,java,role='last-code']
----
@EntityView(Cat.class)
public interface CatView {

    @IdMapping("id")
    Integer getId();

    @MappingSubquery(KittensWithNamePatternSubqueryProvider.class)
    Integer getNumKittensWithNamePattern();

    static class KittensWithNamePatternSubqueryProvider implements SubqueryProvider {
        <T> T createSubquery(SubqueryInitiator<T> subqueryInitiator) {
            return subqueryBuilder.from(Cat.class)
                        .select("COUNT(*)")
                        .where("cat.parent.id").eqExpression("OUTER(id)")
                        .where("cat.name").like().expression(":kittenNamePattern")
                        .end();
        }
    }
}
----

== Example View - Subview

[source,java]
----
@EntityView(Cat.class)
public interface CatView {

    @IdMapping("id")
    Integer getId();

    PersonView getCatOwner();
}

@EntityView(Person.class)
public interface PersonView {

    @IdMapping("id")
    Integer getId();

    String getName();
}
----

== Pagination

Blaze-persistence supports two types of pagination:

* Offset pagination
* Keyset pagination

Keyset pagination is preferable to offset pagination since it allows consistent pagination of data while elements are inserted.

Pagination can also be combined with entity-views!

== Offset pagination example

[source,java]
----
PagedList<Cat> page1 = cbf.create(em, Cat.class)
                .orderByAsc("id")
                .page(0, 10)
                .getResultList()

PagedList<Cat> page2 = cbf.create(em, Cat.class)
                .orderByAsc("id")
                .page(10, 10)
                .getResultList()
----

== Keyset pagination example

[source,java]
----
PagedList<Cat> page1 = cbf.create(em, Cat.class)
                .orderByAsc("id")
                .page(0, 10)
                .withKeysetExtraction(true)
                .getResultList()

PagedList<Cat> page2 = cbf.create(em, Cat.class)
                .orderByAsc("id")
                .page(page1.getKeysetPage(), 10, 10)
                .withKeysetExtraction(true)
                .getResultList()
----

== Common Table Expressions

Common Table Expressions (CTEs) are disposable tables created in memory only for the current statement.

Use cases:

* If you need to refer to a subquery multiple times, it can be convenient to extract it into a CTE - this way the subquery is evaluated only once
* With CTEs it is possible to query recursive structures efficiently

CTEs can also be combined with pagination and entity-views!

== CTE example

[source,java, role = 'smallcode']
----
public <T> List<T> getCatHierarchy(Integer catId, EntityViewSetting<T, CriteriaBuilder<T>> setting) {
    CriteriaBuilder<Tuple> cb = cbf.create(emHolder.getEntityManager(), Tuple.class)
            .withRecursive(CatHierarchyCTE.class)
                .from(Cat.class)
                .bind("id").select("id")
                .bind("motherId").select("mother.id")
                .bind("fatherId").select("father.id")
                .bind("generation").select("0")
                .where("id").eqExpression(catId.toString())
            .unionAll()
                .from(Cat.class, "cat")
                .from(CatHierarchyCTE.class, "cte")
                .bind("id").select("cat.id")
                .bind("motherId").select("cat.mother.id")
                .bind("fatherId").select("cat.father.id")
                .bind("generation").select("cte.generation + 1")
                .whereOr()
                    .where("cat.id").eqExpression("cte.motherId")
                    .where("cat.id").eqExpression("cte.fatherId")
                .endOr()
            .end()
            .from(Cat.class, "cat")
            .innerJoinOn(CatHierarchyCTE.class, "cte").on("cte.id").eqExpression("cat.id").end()
            .orderByAsc("cte.generation");

    return evm.applySetting(setting, cb).getResultList();
}
----

Use like:

[source, java, role = 'smallcode']
----
EntityViewSetting<CatView, CriteriaBuilder<CatView>> catSetting = EntityViewSetting.create(CatView.class);
List<CatView> catHierarchy = getCatHierarchy(1, catSetting);
----

[canvas-image="images/show_me_a_demo.jpg"]
== Demo

== Integrations

Hibernate is the only JPA provider that has deep integration right now:

* Fixes/workarounds for known Hibernate bugs + limitations
* Support for advanced SQL features like CTEs

We provide integrations for CDI and Spring allowing the auto-discovery of entity views.

== Getting started with CDI

[source, java]
----
@ApplicationScoped
public class BlazePersistenceProducer {

    @Inject
    private EntityManagerFactory emf;

    @Inject
    private EntityViewConfiguration entityViewConfiguration;

    @Produces @ApplicationScoped
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        return config.createCriteriaBuilderFactory(emf);
    }

    @Produces @ApplicationScoped
    public EntityViewManager createEntityViewManager(CriteriaBuilderFactory criteriaBuilderFactory) {
        return entityViewConfiguration.createEntityViewManager(criteriaBuilderFactory, emf);
    }
}
----

== Getting started with Spring

[source, java]
----
@Configuration
public class BlazePersistenceConfiguration {

    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;

    @Bean @Lazy(false)
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    public CriteriaBuilderFactory createCriteriaBuilderFactory() {
        CriteriaBuilderConfiguration config = Criteria.getDefault();
        // do some configuration
        return config.createCriteriaBuilderFactory(entityManagerFactory);
    }

    @Bean @Lazy(false)
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    public EntityViewManager createEntityViewManager(CriteriaBuilderFactory cbf,
        EntityViewConfiguration entityViewConfiguration) {
        return entityViewConfiguration.createEntityViewManager(cbf, entityManagerFactory);
    }
}
----

== Roadmap

// List new features that are about to come

* Updateable entity views
* Table function support e.g. `generate_series()`
* `MERGE`/`UPSERT` statement
* Geospatial types and operations
* Range/Interval types and operations
* Lateral joins
* Custom static metamodel
* https://github.com/debezium[Debezium] integration to update secondary index servers via entity views

[canvas-image="images/give_up_on_jpa.jpg"]
== Don't give up on JPA

== Community & Support

https://blazebit.herokuapp.com[Slack]::
We have notifications enabled, so just ask questions :)

https://github.com/Blazebit/blaze-persistence/issues[GitHub issues]::
If you've found a bug or question, just create an issue

https://stackoverflow.com/questions/tagged/blaze-persistence[Stackoverflow]::
Don't hesitate to ask questions there too, we are listening

https://persistence.blazebit.com/support.html[Commercial support & training]::
We help you to get the most out of Blaze-Persistence

== Q & A

+++<h1 style="text-align: center;">Got questions?</h1>+++
